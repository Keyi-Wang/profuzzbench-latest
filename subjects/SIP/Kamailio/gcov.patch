diff --git a/src/main.c b/src/main.c
index 472772d793..613c156c8a 100644
--- a/src/main.c
+++ b/src/main.c
@@ -752,6 +752,7 @@ static void shutdown_children(int sig, int show_status)
 	set_sig_h(SIGALRM, SIG_IGN);
 }
 
+extern void __gcov_dump(void);
 
 void handle_sigs(void)
 {
@@ -772,6 +773,7 @@ void handle_sigs(void)
 		case SIGINT:
 		case SIGTERM:
 			/* we end the program in all these cases */
+			__gcov_dump(); 
 			if(sig_flag == SIGINT)
 				LM_DBG("INT received, program terminates\n");
 			else
@@ -1468,9 +1470,9 @@ int main_loop(void)
 		/* Register the children that will keep updating their
 		 * local configuration */
 		cfg_register_child(1   /* main = udp listener */
-						   + 1 /* timer */
+						//    + 1 /* timer */
 #ifdef USE_SLOW_TIMER
-						   + 1 /* slow timer */
+						//    + 1 /* slow timer */
 #endif
 		);
 		if(do_suid() == -1)
@@ -1505,46 +1507,48 @@ int main_loop(void)
 
 #ifdef USE_SLOW_TIMER
 		/* we need another process to act as the "slow" timer*/
-		pid = fork_process(PROC_TIMER, "slow timer", 0);
-		if(pid < 0) {
-			LM_CRIT("Cannot fork\n");
-			goto error;
-		}
-		if(pid == 0) {
-			/* child */
-			/* timer!*/
-			if(real_time & 2)
-				set_rt_prio(rt_timer2_prio, rt_timer2_policy);
-
-			if(arm_slow_timer() < 0)
-				goto error;
-			slow_timer_main();
-		} else {
-			slow_timer_pid = pid;
-		}
+		
+		// pid = fork_process(PROC_TIMER, "slow timer", 0);
+		// if(pid < 0) {
+		// 	LM_CRIT("Cannot fork\n");
+		// 	goto error;
+		// }
+		// if(pid == 0) {
+		// 	/* child */
+		// 	/* timer!*/
+		// 	if(real_time & 2)
+		// 		set_rt_prio(rt_timer2_prio, rt_timer2_policy);
+
+		// 	if(arm_slow_timer() < 0)
+		// 		goto error;
+		// 	slow_timer_main();
+		// } else {
+		// 	slow_timer_pid = pid;
+		// }
+	
 #endif
 		/* we need another process to act as the "main" timer*/
-		pid = fork_process(PROC_TIMER, "timer", 0);
-		if(pid < 0) {
-			LM_CRIT("Cannot fork\n");
-			goto error;
-		}
-		if(pid == 0) {
-			/* child */
-			/* timer!*/
-			if(real_time & 1)
-				set_rt_prio(rt_timer1_prio, rt_timer1_policy);
-			if(arm_timer() < 0)
-				goto error;
-			timer_main();
-		} else {
-			/* do nothing for main timer */
-		}
-
-		if(sr_wtimer_start() < 0) {
-			LM_CRIT("Cannot start wtimer\n");
-			goto error;
-		}
+		// pid = fork_process(PROC_TIMER, "timer", 0);
+		// if(pid < 0) {
+		// 	LM_CRIT("Cannot fork\n");
+		// 	goto error;
+		// }
+		// if(pid == 0) {
+		// 	/* child */
+		// 	/* timer!*/
+		// 	if(real_time & 1)
+		// 		set_rt_prio(rt_timer1_prio, rt_timer1_policy);
+		// 	if(arm_timer() < 0)
+		// 		goto error;
+		// 	timer_main();
+		// } else {
+		// 	/* do nothing for main timer */
+		// }
+
+		// if(sr_wtimer_start() < 0) {
+		// 	LM_CRIT("Cannot start wtimer\n");
+		// 	goto error;
+		// }
 		/* main process, receive loop */
 		process_no = 0; /*main process number*/
 		pt[process_no].pid = getpid();
@@ -1581,11 +1585,11 @@ int main_loop(void)
 		/* Register the children that will keep updating their
 		 * local configuration. (udp/tcp/sctp listeneres
 		 * will be added later.) */
-		cfg_register_child(1 /* timer */
+		// cfg_register_child(1 /* timer */
 #ifdef USE_SLOW_TIMER
-						   + 1 /* slow timer */
+						//    + 1 /* slow timer */
 #endif
-		);
+		// );
 
 		for(si = udp_listen; si; si = si->next) {
 			/* create the listening socket (for each address)*/
@@ -1988,39 +1992,39 @@ int main_loop(void)
 
 #ifdef USE_SLOW_TIMER
 		/* fork again for the "slow" timer process*/
-		pid = fork_process(PROC_TIMER, "slow timer", 1);
-		if(pid < 0) {
-			LM_CRIT("cannot fork \"slow\" timer process\n");
-			goto error;
-		} else if(pid == 0) {
-			/* child */
-			if(real_time & 2)
-				set_rt_prio(rt_timer2_prio, rt_timer2_policy);
-			if(arm_slow_timer() < 0)
-				goto error;
-			slow_timer_main();
-		} else {
-			slow_timer_pid = pid;
-		}
+		// pid = fork_process(PROC_TIMER, "slow timer", 1);
+		// if(pid < 0) {
+		// 	LM_CRIT("cannot fork \"slow\" timer process\n");
+		// 	goto error;
+		// } else if(pid == 0) {
+		// 	/* child */
+		// 	if(real_time & 2)
+		// 		set_rt_prio(rt_timer2_prio, rt_timer2_policy);
+		// 	if(arm_slow_timer() < 0)
+		// 		goto error;
+		// 	slow_timer_main();
+		// } else {
+		// 	slow_timer_pid = pid;
+		// }
 #endif /* USE_SLOW_TIMER */
 
 		/* fork again for the "main" timer process*/
-		pid = fork_process(PROC_TIMER, "timer", 1);
-		if(pid < 0) {
-			LM_CRIT("cannot fork timer process\n");
-			goto error;
-		} else if(pid == 0) {
-			/* child */
-			if(real_time & 1)
-				set_rt_prio(rt_timer1_prio, rt_timer1_policy);
-			if(arm_timer() < 0)
-				goto error;
-			timer_main();
-		}
-		if(sr_wtimer_start() < 0) {
-			LM_CRIT("Cannot start wtimer\n");
-			goto error;
-		}
+		// pid = fork_process(PROC_TIMER, "timer", 1);
+		// if(pid < 0) {
+		// 	LM_CRIT("cannot fork timer process\n");
+		// 	goto error;
+		// } else if(pid == 0) {
+		// 	/* child */
+		// 	if(real_time & 1)
+		// 		set_rt_prio(rt_timer1_prio, rt_timer1_policy);
+		// 	if(arm_timer() < 0)
+		// 		goto error;
+		// 	timer_main();
+		// }
+		// if(sr_wtimer_start() < 0) {
+		// 	LM_CRIT("Cannot start wtimer\n");
+		// 	goto error;
+		// }
 
 		/* init childs with rank==MAIN before starting tcp main (in case they want
 	 * to fork  a tcp capable process, the corresponding tcp. comm. fds in
